#!/bin/sh
#-----------------------------------------------------------------------------
# Copyright (C) 2005,2006 Dell Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   - Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#
#   - Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#
#   - Neither the name of Dell Inc. nor the names of its contributors may be
#     used to endorse or promote products derived from this software without
#     specific prior written permission.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL Intel Corp. OR THE CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#-----------------------------------------------------------------------------

#set -x
REPEAT=1
BASEDIR=`dirname ${0}`
CONFIGFILE="${BASEDIR}/etc/opentestman.cfg"

if [ ! -z "${1}" -a -d "${1}" ]; then
TESTDATADIR=${BASEDIR}/${1}
else
TESTDATADIR=${BASEDIR}/tests
fi

RUNREMOTE=0
declare -a RM_CONNECT_STR
declare -a RM_TEST_DIRS
declare -a RM_IPADDRESS
PLINK="${BASEDIR}/etc/ssh/plink.exe"

RESULTSDIR=${BASEDIR}/results
UTILDIR=${BASEDIR}/etc
UTIL_SH_DIR=${UTILDIR}/bash

STARTTIME=`date`
STARTHR=`date '+%H'`
STARTMN=`date '+%M'`
STARTSC=`date '+%S'`

#TESTDATAFILELIST="command.txt expected-output.txt"
TESTDATAFILELIST="command.txt"

VALIDTESTDIRS=""
INVALIDTESTDIRS=""

NUM_TESTS_EXECUTED=0
NUM_TESTS_PASSED=0
NUM_TESTS_FAILED=0
NUM_TESTS_UNSUPPORTED=0

CHASSISMODEL=
OSNAME=
OSVERSION=

##
##
##
function GetSystemInfo {
  SYSCMD="omreport"
  if [ "${CAT_EXEC_MODE}" = "remote" ]; then
    SYSCMD="${PLINK} ${CAT_CRC_STR} ${SYSCMD}"
  fi
  CHASSISMODEL="`${SYSCMD} chassis info | grep 'Chassis Model' | sed "s/^.*: //"`"
  OSNAME="`${SYSCMD} system operatingsystem | grep '^Operating System[[:space:]]*:' | sed "s/^Operating.*: //"`"
  OSVERSION="`${SYSCMD} system operatingsystem | grep "^[[:space:]]*Operating System Version" | sed "s/^.*: //"`"
  RESULTSCM="`echo "${CHASSISMODEL}" | sed "s/[[:space:]]//g"`"
}

##
##
##
function CleanTestDir {
  find ${TESTDATADIR} -name "*stdout*.txt"      | xargs -l rm -f >/dev/null 2>&1
  find ${TESTDATADIR} -name "*return_code*.txt" | xargs -l rm -f >/dev/null 2>&1
  find ${TESTDATADIR} -name "*.tmp"             | xargs -l rm -f >/dev/null 2>&1
  find ${TESTDATADIR} -name "*.cmp"             | xargs -l rm -f >/dev/null 2>&1
  rm -f ${RESULTSDIR}/execoutput.txt
}

##
##
##
function UpdateTestCaseRunInfo {
  CUR_TEST_DIR="${1}"
  CUR_TESTCASE_NUM="${2}"

cat <<EOF >>${RESULTSFILE}
<table style="width: 100%; text-align: left;" border="1" cellpadding="0" cellspacing="0"><tbody>
<!-- row 1 -->
<tr><td style="vertical-align: top;">
<table style="width: 100%; text-align: left;" border="1" cellpadding="2" cellspacing="2"><tbody>
<tr><td style="width: 200px; vertical-align: top;">
<span style="font-weight: bold;">Test Case #</span><br>
</td><td style="vertical-align: top;">
<span style="font-weight: bold;">Command</span><br></td></tr>
<tr><td style="vertical-align: top;">
EOF
echo "<a href=\"#Test_Run_Summary_TOP\" name=\"testcase${CUR_TESTCASE_NUM}\">[Top]</a>" >> ${RESULTSFILE}
echo "${CUR_TESTCASE_NUM}"                                                              >> ${RESULTSFILE}
echo " : ${CUR_TEST_DIR}"                                                               >> ${RESULTSFILE}
echo "<br></td><td style=\"vertical-align: top;\">"                                     >> ${RESULTSFILE}
cat  "${CUR_TEST_DIR}/command.txt"                     >> ${RESULTSFILE}

cat <<EOF >>${RESULTSFILE}
<br></td></tr></tbody></table></tr>
<!-- row 2 -->
<!-- row 3 -->
<tr><td style="vertical-align: top;">
<table style="width: 100%; text-align: left;" border="1" cellpadding="2" cellspacing="2"><tbody>
<tr><td style="vertical-align: top;"><span style="font-weight: bold;">Test Case Description</span>
<br></td></tr><tr><td style="vertical-align: top;">
EOF

# add description if available
if [ -f ${CUR_TEST_DIR}/description.txt ]; then
  cat  "${CUR_TEST_DIR}/description.txt" >> ${RESULTSFILE}
fi

cat <<EOF >>${RESULTSFILE}
<br></td></tr></tbody></table></td></tr>
<!-- row 4 -->
<!-- row 5 -->
<tr><td style="vertical-align: top;">
<table style="width: 100%; text-align: left;" border="1" cellpadding="2" cellspacing="2"><tbody>
<tr><td style="vertical-align: top; text-align: center;">
<span style="font-weight: bold;">Expected Result</span><br></td>
<td style="vertical-align: top; text-align: center;">
<span style="font-weight: bold;">Actual Result</span><br>
</td></tr><tr><td style="vertical-align: top;">
<pre>
EOF

if [ -f ${CUR_TEST_DIR}/expected-output.txt ]; then
  cat  "${CUR_TEST_DIR}/expected-output.txt" | sed "s/\"/\&quot;/g" | sed "s/</\&lt;/g" | sed "s/>/\&gt;/g"  >> ${RESULTSFILE}
  echo "</pre><br></td><td style=\"vertical-align: top;\"><pre>"  >> ${RESULTSFILE}
else
  echo "Ignoring basic text comparision" | sed "s/\"/\&quot;/g" | sed "s/</\&lt;/g" | sed "s/>/\&gt;/g"  >> ${RESULTSFILE}
  echo "</pre><br></td><td style=\"vertical-align: top;\"><pre>"  >> ${RESULTSFILE}
fi

cat  "${CUR_TEST_DIR}/stdout.txt" | sed "s/\"/\&quot;/g" | sed "s/</\&lt;/g" | sed "s/>/\&gt;/g"  >> ${RESULTSFILE}
echo "</pre><br></td></tr></tbody></table></td></tr>"      >> ${RESULTSFILE}

cat <<EOF >>${RESULTSFILE}
<!-- row 6 -->
<!-- row 7 -->
<tr><td style="vertical-align: top;">
<table style="width: 100%; text-align: left;" border="1" cellpadding="2" cellspacing="2"><tbody>
<tr><td style="vertical-align: top;">
<span style="font-weight: bold;">Basic Result Comparision using (diff command)</span><br>
</td><td style="vertical-align: top;">
<span style="font-weight: bold;">Detailed Result Processing by using</span><br></td>
<td style="width: 150px; vertical-align: top;">
<span style="font-weight: bold;">Final Result</span><br style="font-weight: bold;">
<span style="font-weight: bold;">Test case Pass/Fail</span><br>
</td></tr><tr>
EOF

if [ 0 == "`cat ${CUR_TEST_DIR}/return_code.txt`" ]; then
  echo "<td style=\"vertical-align: top; background-color: rgb(153, 255, 153); font-weight: bold;\">" >> ${RESULTSFILE}
  echo "Expected output and Actual output are same"      >> ${RESULTSFILE}
else
  echo "<td style=\"vertical-align: top; background-color: rgb(255, 204, 204); font-weight: bold;\">" >> ${RESULTSFILE}
  echo "Expected output and Actual output are different" >> ${RESULTSFILE}
fi
echo "<br></td><td style=\"vertical-align: top;\">"      >> ${RESULTSFILE}
if [ -f "${CUR_TEST_DIR}/testresults.sh" ]; then
  echo "${CUR_TEST_DIR}/testresults.sh"                  >> ${RESULTSFILE}
  echo "<pre>"                                           >> ${RESULTSFILE}
  cat  "${CUR_TEST_DIR}/results.stdout.txt"              >> ${RESULTSFILE}
  echo "</pre>"                                          >> ${RESULTSFILE}
fi
echo "<br></td>"                                         >> ${RESULTSFILE}
if [ -f "${CUR_TEST_DIR}/results_return_code.txt" ]; then
  if [ 0 == "`cat ${CUR_TEST_DIR}/results_return_code.txt`" ]; then
    echo "<td style=\"vertical-align: top; background-color: rgb(153, 255, 153); font-weight: bold;\">PASS<br></td>" >> ${RESULTSFILE}
  else
    echo "<td style=\"vertical-align: top; background-color: rgb(255, 0, 0); font-weight: bold;\">FAIL<br></td>"     >> ${RESULTSFILE}
  fi
else
  if [ 0 == "`cat ${CUR_TEST_DIR}/return_code.txt`" ]; then
    echo "<td style=\"vertical-align: top; background-color: rgb(153, 255, 153); font-weight: bold;\">PASS<br></td>" >> ${RESULTSFILE}
  else
    echo "<td style=\"vertical-align: top; background-color: rgb(255, 0, 0); font-weight: bold;\">FAIL<br></td>"     >> ${RESULTSFILE}
  fi
fi
echo "</tr></tbody></table></td></tr></tbody></table>"   >> ${RESULTSFILE}

}

##
##
##
function UpdateSummaryInfo {
  # variables to be replaced are:
  TOTAL_CASES="`find ${TESTDATADIR} -type f | xargs -l dirname | uniq | wc -l`"
  TOTAL_EXECUTED="${NUM_TESTS_EXECUTED}"
  #TOTAL_UNSUPPORTED="`find ${TESTDATADIR} -name "testcasenotsupported" | xargs -l dirname 2>/dev/null | uniq | wc -l`"
  TOTAL_BAD="`expr ${TOTAL_CASES} - ${TOTAL_EXECUTED}`"
  TOTAL_PASSED="${NUM_TESTS_PASSED}"
  TOTAL_FAILED="${NUM_TESTS_FAILED}"
  TOTAL_SUPPORTED=`expr ${TOTAL_EXECUTED} - ${NUM_TESTS_UNSUPPORTED}`
  
  # calculate Pass/Fail percentages
  rm -f ./calc_prct >/dev/null 2>&1
  rm -f ./pf_prct   >/dev/null 2>&1
  echo "${TOTAL_PASSED} ${TOTAL_SUPPORTED}" >> ./calc_prct
  awk -v tmpfile="./pf_prct" '{
     pprct=($1*100)/$2; 
     fprct=100-pprct; 
     print "PASS="pprct"\nFAIL="fprct >> tmpfile
   }' ./calc_prct   
  PPRCT=`cat ./pf_prct | grep "PASS" | sed "s/^PASS=//"`
  FPRCT=`cat ./pf_prct | grep "FAIL" | sed "s/^FAIL=//"`
  rm -f ./calc_prct >/dev/null 2>&1
  rm -f ./pf_prct   >/dev/null 2>&1
  
  TMPRESULTSFILE="${RESULTSFILE}.tmp"
  sed "s#RPL_SERVER_MODEL#${CHASSISMODEL}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_OPERATING_SYSTEM#${OSNAME}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_OSVER#${OSVERSION}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_TOTAL_CASES#${TOTAL_CASES}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_TOTAL_BAD#${TOTAL_BAD}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_TOTAL_EXECUTED#${TOTAL_EXECUTED}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_TOTAL_PASSED#${TOTAL_PASSED}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_TOTAL_FAILED#${TOTAL_FAILED}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_TOTAL_UNSUPPORTED#${NUM_TESTS_UNSUPPORTED}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_START_TIME#${STARTTIME}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_PASS_PERCT#${PPRCT}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_FAIL_PERCT#${FPRCT}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
    
  ENDTIME="`date`"
  ENDHR=`date '+%H'`
  ENDMN=`date '+%M'`
  ENDSC=`date '+%S'`
    
  STARTHR=`expr ${STARTHR} \* 3600`  
  STARTMN=`expr ${STARTMN} \* 60`
  ENDHR=`expr ${ENDHR} \* 3600`
  ENDMN=`expr ${ENDMN} \* 60`
  STARTOTALSC=`expr ${STARTHR} + ${STARTMN} + ${STARTSC}`
  ENDTOTALSC=`expr ${ENDHR} + ${ENDMN} + ${ENDSC}`
  EXECTOTALSC=`expr ${ENDTOTALSC} - ${STARTOTALSC}`
  EXECHR=`expr ${EXECTOTALSC} / 3600`
  EXECHRRM=`expr ${EXECTOTALSC} % 3600`
  EXECMN=`expr ${EXECHRRM} / 60`
  EXECSC=`expr ${EXECHRRM} % 60`
    
  sed "s#RPL_END_TIME#${ENDTIME}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_EXEC_TIME_HR#${EXECHR}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_EXEC_TIME_MN#${EXECMN}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
  sed "s#RPL_EXEC_TIME_SC#${EXECSC}#g" ${RESULTSFILE} >${TMPRESULTSFILE} && (mv ${TMPRESULTSFILE} ${RESULTSFILE})
}

##
##
##
function GenerateHTMLReport {
  # add header and summary information
  cat ${UTILDIR}/templates/html-template-report-header.txt       >> ${RESULTSFILE}
  echo "<pre>"                                                   >> ${RESULTSFILE}
  cat ${RESULTSDIR}/execoutput.txt                               >> ${RESULTSFILE}
  echo "</pre>"                                                  >> ${RESULTSFILE}
  cat ${UTILDIR}/templates/html-template-report-summary.txt      >> ${RESULTSFILE}
  UpdateSummaryInfo
  # add a new table template for each test case
  if [ ! -z "${VALIDTESTDIRS}" ]; then
    cat ${UTILDIR}/templates/html-template-report-testcaserunheader.txt  >> ${RESULTSFILE}
    CUR_TESTCASE_NUM=0
    for i in ${VALIDTESTDIRS}; do
      UpdateTestCaseRunInfo "${i}" "`expr ${CUR_TESTCASE_NUM} + 1`"
      cat ${UTILDIR}/templates/html-template-report-testcaserunfooter.txt  >> ${RESULTSFILE}
    done
  fi
  # add report footer
  cat ${UTILDIR}/templates/html-template-report-footer.txt       >> ${RESULTSFILE}
}

##
##
##
function ExecuteTest {
  TEST_DIR="${1}"
  TEST_CMD="`cat ${TEST_DIR}/command.txt`"

  echo "${TEST_CMD}" | grep "UTIL_SH_DIR" > /dev/null
  if [ $? = 0 ]; then
    TEST_CMD="`echo "${TEST_CMD}" | sed "s#UTIL_SH_DIR#${UTIL_SH_DIR}#"`"
  fi

  echo "${TEST_CMD}" | grep "TEST_DIR" > /dev/null
  if [ $? = 0 ]; then
    TEST_CMD="`echo "${TEST_CMD}" | sed "s#TEST_DIR#${TEST_DIR}#"`"
  fi
###  echo $TEST_CMD
  # execution type is remote, add remote connect
  if [ "${CAT_EXEC_MODE}" == "remote" ]; then
    # handle special case "smash -c"
    echo "${TEST_CMD}" | grep "smash -c" >/dev/null 2>&1
    if [ $? = 0 ]; then
      # replace smash -c with empty string
      TEST_CMD=`echo "${TEST_CMD}" | sed "s/^smash -c //" 2>/dev/null`
    fi
    TEST_CMD="${PLINK} ${CAT_CRC_STR} ${TEST_CMD}"
  fi
  # run command.txt
  ${TEST_CMD} >${TEST_DIR}/stdout.txt 2>&1
  #cat ${TEST_DIR}/stdout.txt
  [ -s "${TEST_DIR}/stdout.txt" ] && dos2unix ${TEST_DIR}/stdout.txt >/dev/null 2>&1
  cat ${TEST_DIR}/stdout.txt | tr -s '\n\t ' | tr '\n' '|' > ${TEST_DIR}/stdout.tmp

  LEVEL_ONE="true"
  LEVEL_TWO="skip"
  if [ -f ${TEST_DIR}/ignore_basictext_comparision ]; then
    # ignore LEVEL_ONE
    LEVEL_ONE="skip"
  fi
  
  if [ -f "${TEST_DIR}/testresults.sh" ]; then
    # LEVEL_TWO requested
    LEVEL_TWO="true"
  fi

 # primary text comparision if necessary
  if [ "${LEVEL_ONE}" == "true" ]; then
    if [ -s ${TEST_DIR}/expected-output.txt ]; then		
	dos2unix "${TEST_DIR}/expected-output.txt" >/dev/null 2>&1	  
	# primary result comparision, compare one line at a line
	#${UTIL_SH_DIR}/comparelines.sh ${TEST_DIR}/expected-output.txt ${TEST_DIR}/stdout.txt
	diff ${TEST_DIR}/expected-output.txt ${TEST_DIR}/stdout.txt >/dev/null 2>&1
	echo "$?" >${TEST_DIR}/return_code.txt
    else
        echo "1" >${TEST_DIR}/return_code.txt
    fi
  else
    # LEVEL_ONE is skipped, if LEVEL_TWO is also set to skip then
    # test case should be marked failed, because no pass/fail criterion is available
    if [ "${LEVEL_TWO}" == "true" ]; then
      echo "0" >${TEST_DIR}/return_code.txt
    else
      echo "1" >${TEST_DIR}/return_code.txt
    fi
  fi
  
  # if further results processing requested?
  if [ "${LEVEL_TWO}" == "true" ]; then
    sh ${TEST_DIR}/testresults.sh ${TEST_DIR} ${BASEDIR} >${TEST_DIR}/results.stdout.txt 2>&1
    echo "$?" >${TEST_DIR}/results_return_code.txt
  fi
  # mark test passed/failed
  # check the results of LEVEL_TWO first and then LEVEL_ONE (if LEVEL_TWO not available)
  if [ -f "${TEST_DIR}/testcasenotsupported" ]; then
    NUM_TESTS_UNSUPPORTED=`expr ${NUM_TESTS_UNSUPPORTED} + 1`
  elif [ -f "${TEST_DIR}/results_return_code.txt" ]; then
    if [ 0 == "`cat ${TEST_DIR}/results_return_code.txt`" ]; then
      NUM_TESTS_PASSED=`expr ${NUM_TESTS_PASSED} + 1`
    else
      NUM_TESTS_FAILED=`expr ${NUM_TESTS_FAILED} + 1`
    fi
  else
    if [ 0 == "`cat ${TEST_DIR}/return_code.txt`" ]; then
      NUM_TESTS_PASSED=`expr ${NUM_TESTS_PASSED} + 1`
    else
      NUM_TESTS_FAILED=`expr ${NUM_TESTS_FAILED} + 1`
    fi
  fi

  NUM_TESTS_EXECUTED=`expr ${NUM_TESTS_EXECUTED} + 1`
}

function validateTestDir {
  # check for additional testcase directories
  #TESTDIR_PE2850=tc-smclp-2850
  for NewTestDir in `grep "^TESTDIR_PE" ${CONFIGFILE}`; do
    DIRKEY=`echo "${NewTestDir}" | sed  "s/=.*$//" `
    DIRVAL=`echo "${NewTestDir}" | sed  "s/^.*=//" `
    CHM=`echo ${CHASSISMODEL} | sed "s/PowerEdge //"`
    if [ "${DIRKEY}" == "TESTDIR_PE${CHM}" ]; then
	  # copy the files
	  cp -rf ${BASEDIR}/${DIRVAL} ${TESTDATADIR}/
    fi
  done
  
  clear
  echo ""
  echo "Scanning test case directories ..."
  # scan test data
  if [ "0" != "`find ${TESTDATADIR} -type f | wc -l`" ]; then
  for i in `find ${TESTDATADIR} -type f | xargs -l dirname | uniq`;
  do
    DIRECTORYPATH="${i}"

    VALIDTESTDIR="false"
    for TESTDATAFILE in ${TESTDATAFILELIST};
    do
      VALIDTESTDIR="false"
      if [ -f "${DIRECTORYPATH}/${TESTDATAFILE}" ]; then
        # contains at least one valid file
        VALIDTESTDIR="true"
      else
        break
      fi
    done

    # log bad directories
    if [ "${VALIDTESTDIR}" == "false" ]; then
      INVALIDTESTDIRS="${INVALIDTESTDIRS} ${DIRECTORYPATH}"
    else
      VALIDTESTDIRS="${VALIDTESTDIRS} ${DIRECTORYPATH}"
    fi
  done
  else 
    echo "No test cases found in ${TESTDATADIR}"
    exit 1 
  fi

  # print invalid test directories
  if [ ! -z "${INVALIDTESTDIRS}" ]; then
    echo "Following are not valid test case directories"
    for i in ${INVALIDTESTDIRS}; do
      echo "  - ${i}"
    done
  fi

}

function resetVars {
  NUM_TESTS_EXECUTED=0
  NUM_TESTS_PASSED=0
  NUM_TESTS_FAILED=0
  STARTTIME=`date`
  STARTHR=`date '+%H'`
  STARTMN=`date '+%M'`
  STARTSC=`date '+%S'`
}

function executeRemoteTesting {
  # set execution mode to "remote"
  export CAT_EXEC_MODE="remote"
  for (( ar=0 ; ar<${#RM_CONNECT_STR[*]} ; ar++ ))
  {
    # reset things for current execution
    INVALIDTESTDIRS=""
    VALIDTESTDIRS=""

    echo ""
    echo -n "Connecting to the remote server "
    echo -n "${RM_IPADDRESS[ar]} ... "

    # smash specific    
    ERR_MSG=`${PLINK} ${RM_CONNECT_STR[ar]} "smash -c" 2>&1`

    if [ $? = 0 ]; then
      echo -e "\E[32m Connection successful! "
      tput sgr0
      echo ""
    else
      echo -e "\E[31m Connection failed! "
      tput sgr0
      echo "Error message : $ERR_MSG"
      echo "continue with other servers"
      echo ""
      continue
    fi
    
    # set remote connect string
    export CAT_CRC_STR="${RM_CONNECT_STR[ar]}"
    # set results dir
    RESULTSDIR=${BASEDIR}/results/${RM_IPADDRESS[ar]}/${RM_TEST_DIRS[ar]}
    rm -rf ${RESULTSDIR}
    mkdir -p ${RESULTSDIR}
    cp ${BASEDIR}/results/*.gif ${RESULTSDIR}/
    # set testcase directory
    TESTDATADIR=${RM_TEST_DIRS[ar]}

    # execute tests
    testSuiteRun
  }
}

##
## runRemote
##
function runRemote {
  currentIndex=0
  for i in `grep "^ip=" ${CONFIGFILE}`; do
    entry=${i}
    echo "${entry}" | grep "^ip=" >/dev/null 2>&1
    if [ $? != 0 ]; then
      continue
    fi
    IP=`echo ${entry} | sed "s/;.*$//"`
    entry=`echo ${entry} | sed "s/$IP//;s/;//"`
    USER=`echo ${entry} | sed "s/;.*$//"`
    entry=`echo ${entry} | sed "s/$USER//;s/;//"`
    PASSWD=`echo ${entry} | sed "s/;.*$//"`
    entry=`echo ${entry} | sed "s/$PASSWD//;s/;//"`
    TESTDIR=`echo ${entry} | sed "s/;.*$//"`

    # check for ip
    echo "${IP}" | grep "^ip=" > /dev/null
    if [ $? == 0 ]; then
      IP_value=`echo ${IP} | sed "s/ip=//"`
    else
      echo "Error! Invalid entry in ${CONFIGFILE} file"
      echo "Remote server info bad : ${i}"
      exit 1
    fi

    # check for password
    echo "${PASSWD}" | grep "^password=" > /dev/null
    if [ $? == 0 ]; then
      PASSWD_value=`echo ${PASSWD} | sed "s/password=//"`
    else
      echo "Error! Invalid entry in ${CONFIGFILE} file"
      echo "Remote server info bad : ${i}"
      exit 1
    fi

    # check for username
    echo "${USER}" | grep "^username=" > /dev/null
    if [ $? == 0 ]; then
      USER_value=`echo ${USER} | sed "s/username=//"`
    else
      echo "Error! Invalid entry in ${CONFIGFILE} file"
      echo "Remote server info bad : ${i}"
      exit 1
    fi

    # check for username
    echo "${TESTDIR}" | grep "^testcasedir=" > /dev/null
    if [ $? == 0 ]; then
      TESTDIR_value=`echo ${TESTDIR} | sed "s/testcasedir=//"`
    else
      echo "Error! Invalid entry in ${CONFIGFILE} file"
      echo "Remote server info bad : ${i}"
      exit 1
    fi

    # build the remote connect strings
    CONNECT_STR=" -pw ${PASSWD_value} ${USER_value}@${IP_value} "
    RM_CONNECT_STR[currentIndex]=${CONNECT_STR}
    RM_TEST_DIRS[currentIndex]=${TESTDIR_value}
    RM_IPADDRESS[currentIndex]=`echo ${IP_value} | sed "s/\./-/g"`
    currentIndex=`expr ${currentIndex} + 1`
  done

  executeRemoteTesting
}

##
## readConfig
##
function readConfig {
  dos2unix ${CONFIGFILE} > /dev/null 2>&1
  
  grep "^RUNLOCAL=1$" ${CONFIGFILE} > /dev/null 2>&1
  if [ $? == 0 ]; then
    # run tests locally
    RUNLOCAL=1
  else
    # must be remote
    grep "^RUNREMOTE=1$" ${CONFIGFILE} > /dev/null 2>&1
    if [ $? == 0 ]; then
      # run tests remotely
      RUNREMOTE=1
    else
      echo "Error! Invalid config entries in ${CONFIGFILE}"
      echo "Unable to decide which test cases to run"
      exit 1
    fi
  fi
}

##
## TestSuiteRun
##
function testSuiteRun {
  # get system info
  echo "Gathering system info ..."
  GetSystemInfo

  # validate test directories
  validateTestDir

  # execute tests
  if [ ! -z "${VALIDTESTDIRS}" ]; then
    echo "Executing test cases ..."
    for (( j = 1 ; j <= ${REPEAT} ; j++ ));
    do
      resetVars
      RESULTSDATE=`date '+%Y-%m-%d-%H.%M.%S'`
      if [ ${REPEAT} -gt 1 ]; then
        RESULTSFILE=${RESULTSDIR}/${RESULTSCM}-${RESULTSDATE}"-TestRun-${j}-results.html"
      else
        RESULTSFILE=${RESULTSDIR}/"report.html"
      fi
      echo "Test Run: ${j}"
      echo "Cleaning any residue from previous executions ..."
      CleanTestDir
      
      TESTNUM=0
      for TESTDIR in ${VALIDTESTDIRS}; do
        TESTNUM=`expr ${TESTNUM} + 1`
        printf  " -> %3d." $TESTNUM 
        printf  " -> %3d." $TESTNUM >> ${RESULTSDIR}/execoutput.txt
        echo -n " ${TESTDIR} "
        echo -n " ${TESTDIR} " >> ${RESULTSDIR}/execoutput.txt

        NUMSPACECHAR=`echo "${TESTDIR}" | wc -m`
        if [ ${NUMSPACECHAR} -lt 62 ]; then
          NUMSPACECHAR=`expr 62 - ${NUMSPACECHAR}`
          for (( i=0 ; i<${NUMSPACECHAR} ; i++ ));
          do
            echo -n " "
	    echo -n " " >> ${RESULTSDIR}/execoutput.txt
          done
        fi

        ExecuteTest "${TESTDIR}"
        if [ -f "${TESTDIR}/testcasenotsupported" ]; then
            echo -n "["
            echo -n -e "\E[33m Warn "
            tput sgr0
            echo "]"
            echo "[ <a href=\"#testcase${TESTNUM}\" alt=\"Test case not supported\"><img border=\"0\" src=\"warn.gif\" alt=\"Testcase is not supported on this system\"></a> ]" >> ${RESULTSDIR}/execoutput.txt
        elif [ -f "${TESTDIR}/results_return_code.txt" ]; then
          if [ 0 == "`cat ${TESTDIR}/results_return_code.txt`" ]; then
            echo -n "["
            echo -n -e "\E[32m Pass "
            tput sgr0
            echo "]"
            echo "[ <a href=\"#testcase${TESTNUM}\"><img border=\"0\" src=\"pass.gif\" alt=\"Testcase Passed\"></a> ]" >> ${RESULTSDIR}/execoutput.txt
          else
            echo -n "["
            echo -n -e "\E[31m Fail "
            tput sgr0
            echo "]"
            echo "[ <a href=\"#testcase${TESTNUM}\"><img border=\"0\" src=\"fail.gif\" alt=\"Testcase Failed\"></a> ]" >> ${RESULTSDIR}/execoutput.txt
          fi
        else
          if [ 0 == "`cat ${TESTDIR}/return_code.txt`" ]; then
            echo -n "["
            echo -n -e "\E[32m Pass "
            tput sgr0
            echo "]"
            echo "[ <a href=\"#testcase${TESTNUM}\"><img border=\"0\" src=\"pass.gif\" alt=\"Testcase Passed\"></a> ]" >> ${RESULTSDIR}/execoutput.txt
          else
            echo -n "["
            echo -n -e "\E[31m Fail "
            tput sgr0
            echo "]"
            echo "[ <a href=\"#testcase${TESTNUM}\"><img border=\"0\" src=\"fail.gif\" alt=\"Testcase Failed\"></a> ]" >> ${RESULTSDIR}/execoutput.txt
          fi
        fi
      done

      # generate test report
      echo "Generating HTML results report ... "
      GenerateHTMLReport
      echo "Please find the report at : ${RESULTSFILE}"
      echo ""
      
      # cleaning this test run
      echo "Cleaning any residue from Test Run: ${j}"
      CleanTestDir
    done
  else
    echo "There are no valid test cases found"
    exit 1
  fi
}

##
## Main
##
function main {
  # read config file
  readConfig

  # run tests
  if [ "${RUNREMOTE}" = "1" ]; then
    runRemote
  else
    testSuiteRun
  fi
}

main
