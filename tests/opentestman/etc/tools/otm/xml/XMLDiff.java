/*******************************************************************************
 * Copyright (C) 2004-2006 Dell Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  - Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  - Neither the name of Dell Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL Intel Corp. OR THE CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/

/**
 * @author Pritesh Prabhu
 */

package otm.xml;

import javax.xml.parsers.DocumentBuilder; 
import javax.xml.parsers.DocumentBuilderFactory;  
import javax.xml.parsers.FactoryConfigurationError;  
import javax.xml.parsers.ParserConfigurationException;

import org.xml.sax.SAXException;  
import org.xml.sax.SAXParseException;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Stack;
import java.util.Vector;
import java.util.StringTokenizer;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.w3c.dom.DOMException;
import jargs.gnu.CmdLineParser;

public class XMLDiff {
        
	private static Stack nodeStack;
	private static Stack altNodeStack;
	private static Vector ignoreListVector;
	private static boolean debug;
	static {
		nodeStack = new Stack();
		altNodeStack = new Stack();
		ignoreListVector = new Vector();
		debug = false;
	}
	private static void printUsage()
        {
                System.out.println("Usage: XMLDiff <{--file1} filename> <{--file2} filename> [{--ignorelist} comma_separated_list]");
        }

	public static void main (String argv []){
		CmdLineParser parser = new CmdLineParser();
                CmdLineParser.Option debugOption = parser.addBooleanOption("debug");
                CmdLineParser.Option file1Option = parser.addStringOption("file1");
                CmdLineParser.Option file2Option = parser.addStringOption("file2");
                CmdLineParser.Option ignoreListOption = parser.addStringOption("ignorelist");

                try {
                        parser.parse(argv);
                }
                catch ( CmdLineParser.OptionException e ) {
                        System.err.println(e.getMessage());
                        printUsage();
                        System.exit(-3);
                }

                String file1Name = (String)parser.getOptionValue(file1Option);
                String file2Name = (String)parser.getOptionValue(file2Option);


                if(null == file1Name
                        || null == file2Name)
                {
                        System.out.println("Please provide all required command-line arguments");
                        printUsage();
                        System.exit(-2);
                }
                String ignoreList = (String)parser.getOptionValue(ignoreListOption);
                if(null != ignoreList) {
			StringTokenizer st = new StringTokenizer(ignoreList, ",");
			while(st.hasMoreTokens())
				ignoreListVector.add("/#document" + st.nextToken());
		}
		Boolean debugFlag = (Boolean)parser.getOptionValue(debugOption, Boolean.FALSE);                 
		debug = debugFlag.booleanValue();


	try {

            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
            Document doc1 = docBuilder.parse (new File(file1Name));
            Document doc2 = docBuilder.parse (new File(file2Name));

            // normalize text representation
            doc1.getDocumentElement ().normalize ();
            doc2.getDocumentElement ().normalize ();

//		prettyPrint(doc1);
//		System.out.println();
//		prettyPrint(doc2);
//		System.out.println();

		int returnValue = diffDocs(doc1, doc2);
		System.exit(returnValue);

        }catch (SAXParseException err) {
        System.out.println ("** Parsing error" + ", line " 
             + err.getLineNumber () + ", uri " + err.getSystemId ());
        System.out.println(" " + err.getMessage ());

        }catch (SAXException e) {
        Exception x = e.getException ();
        ((x == null) ? e : x).printStackTrace ();

        }catch (FileNotFoundException e) {
        e.printStackTrace ();

        }catch (Throwable t) {
        t.printStackTrace ();
        }
	System.exit(-1);

    }//end of main

	private static void prettyPrint(Node node) {
		prettyPrint(1, node);
	}
	
	private static void prettyPrint(final int tabLevel, Node node) {
		
		for(int i = 0; i < tabLevel; ++i)
			System.out.print("\t");

		System.out.print("<" + node.getNodeName() + ">");

		boolean isLeaf = false;

		if(node.hasChildNodes())
		{
			NodeList childList = node.getChildNodes();
			for(int i = 0; i < childList.getLength(); ++i) {
				if(childList.item(i).getNodeName().equals("#text"))
				{
					System.out.print(childList.item(i).getNodeValue());
					isLeaf = true;
				}
				else
				{
					System.out.println();
					prettyPrint(tabLevel+1, childList.item(i)); 
				}
			}
			
		}
		else
			isLeaf = true;
		if(!isLeaf) { 
			System.out.println();
			for(int i = 0; i < tabLevel; ++i)
				System.out.print("\t");
		}
		System.out.print("</" + node.getNodeName() + ">");
	}

	private static int diffDocs(Node node1, Node node2) {
		nodeStack.push(node1.getNodeName());
		altNodeStack.push(node2.getNodeName());
		NodeList node1ChildList = node1.getChildNodes();
		NodeList node2ChildList = node2.getChildNodes();
		String nodeTrace = returnStackInOrder((Stack)nodeStack.clone());
		String altNodeTrace = returnStackInOrder((Stack)altNodeStack.clone());
		if(debug) System.out.println("Comparing: " + nodeTrace);
		if(ignoreListVector.contains(nodeTrace)) {
			nodeStack.pop();
			altNodeStack.pop();
			if(debug) System.out.println("Ignoring: " + nodeTrace);
			return 0;
		}
		if(node1.getNodeName() != node2.getNodeName()) {
			System.out.println("< " + nodeTrace.substring(10));
			System.out.println("> " + altNodeTrace.substring(10));
			return 1;
		}
		if(node1.getNodeName().equals("#text")) {
			if(!node1.getNodeValue().equals(node2.getNodeValue())) {
				System.out.println("< " + nodeTrace.substring(10) + "/" + node1.getNodeValue());
				System.out.println("> " + altNodeTrace.substring(10) + "/" + node2.getNodeValue());
				return 1;
			}
		}
		if(node1.hasChildNodes() != node2.hasChildNodes()) {
			System.out.println("Children differ");
			return 1;
		}
		if(node1ChildList.getLength() != node2ChildList.getLength()) {
			System.out.println("The number of children differs");
			return 1;
		}
		int returnValue = 0;
		for(int i = 0; i < node1ChildList.getLength(); ++i) {
			if(1 == diffDocs(node1ChildList.item(i), node2ChildList.item(i)))
				return 1;
		}
		nodeStack.pop();
		altNodeStack.pop();
		return 0;
	} 

	private static String returnStackInOrder(Stack stack) {
		if(!stack.empty()) {
			Object top = stack.pop();
			return returnStackInOrder(stack) + "/" + top;
		}
		return "";
	}
}
